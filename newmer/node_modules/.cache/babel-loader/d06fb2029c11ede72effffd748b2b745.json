{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HP\\\\Desktop\\\\wed\\\\newmer\\\\src\\\\Standard\\\\NewtonRaphson.js\";\nimport React from \"react\";\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport Table from 'react-bootstrap/Table';\nimport { compile, derivative } from 'mathjs';\nimport { Collapse } from \"react-bootstrap\";\nvar labelBic = [];\n\nclass NewtonRaphson extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      SumX: \"\",\n      errorX: \"\",\n      X: \"\",\n      talang: false\n    };\n    this.setSumX = this.setSumX.bind(this);\n    this.setX = this.setX.bind(this);\n  }\n\n  setSumX(event) {\n    this.setState({\n      SumX: event.target.value\n    });\n  }\n\n  setX(event) {\n    this.setState({\n      X: event.target.value\n    });\n  }\n\n  runfun(event) {\n    this.setState({\n      talang: event\n    });\n\n    if (event) {\n      labelBic.length = 0;\n      this.fun();\n    }\n  }\n\n  showfun() {\n    return labelBic;\n  }\n\n  fun() {\n    var x = this.state.X,\n        sum = this.state.SumX,\n        fun = \"\",\n        diff = \"\",\n        xold = parseFloat(x),\n        scope = \"\",\n        ffun = \"\",\n        fdif = \"\",\n        xnew = \"\",\n        error = \"\",\n        i = 0;\n\n    while (true) {\n      fun = compile(sum);\n      diff = derivative(sum, \"x\");\n      scope = {\n        x: parseFloat(xold)\n      };\n      ffun = fun.evaluate(scope);\n      fdif = diff.evaluate(scope);\n      xnew = xold - ffun / fdif;\n      error = (xnew - xold) / xnew * 100;\n      xold = xnew;\n      labelBic.push(React.createElement(\"tr\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 48\n        },\n        __self: this\n      }, React.createElement(\"td\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 49\n        },\n        __self: this\n      }, i), React.createElement(\"td\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 50\n        },\n        __self: this\n      }, xold), React.createElement(\"td\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 51\n        },\n        __self: this\n      }, error)));\n      i++;\n\n      if (error < 0.000001 || i > 100) {\n        break;\n      }\n    }\n  }\n\n  render() {\n    const styles = {\n      width: \"250px\"\n    };\n    return React.createElement(\"div\", {\n      className: \"card\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 65\n      },\n      __self: this\n    }, React.createElement(\"label\", {\n      className: \"alert\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66\n      },\n      __self: this\n    }, React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 67\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"alert alert-danger\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 67\n      },\n      __self: this\n    }, \"NewtonRaphson\"), React.createElement(\"div\", {\n      className: \"Contentnumer\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 68\n      },\n      __self: this\n    }, \" The bisection method in mathematics is a root-finding method that repeatedly bisects an interval and then selects a sub-interval in which a root must lie for further processing. It is a very simple and robust method, but it is also relatively slow. Because of this, it is often used to obtain a rough approximation to a solution which is then used as a starting point for more rapidly converging methods. This method is also called the Interval Halving Method, the Binary Search Method, the Dichotomy Method, Robust Root Finding Method and Bolzano\\u2019s Method. It\\u2019s strategy is to begin with two values of x, say xL and xU, that brackets a root of       f(x) = 0. It determines that the initial values x = xL and x = xU. The method treats the interval distance between the initial values as line segment then successively divides the interval in half and replaces one endpoint with the midpoint so that again the root is bracketed. Note : xL for lower limit xU for upper limit xR for average of upper and lower limit () At each step, the method divides the interval in two by computing the midpoint xR = (xL + xU) / 2 of the interval and the value of the function f(xR) at that point. Unless xR is itself a root (which is very unlikely, but possible) there are now two possibilities: either f(xL) and f(xR) have opposite signs and bracket a root, or f(xR) and f(xU) have opposite signs and bracket a root. The method selects the subinterval that is a bracket as a new interval to be used in the next step. In this way the interval that contains a zero of f is reduced in width by 50% at each step. The process is continued until the interval is sufficiently small. Explicitly, if f(xL) and f(xR) are opposite signs, then the method sets xR as the new value for xU, and if f(xL) and f(xR) are same signs then the method sets xR as the new xL. (If f(xR)=0 then xR may be taken as the solution and the process stops.)In both cases, the new f(xL) and f(xU) have opposite signs, so the method is applicable to this smaller interval.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"input-group\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 76\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"input-group-prepend\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 77\n      },\n      __self: this\n    }, React.createElement(\"span\", {\n      className: \"input-group-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 77\n      },\n      __self: this\n    }, \"f(x)\")), React.createElement(\"input\", {\n      type: \"text\",\n      style: styles,\n      value: this.state.SumX,\n      onChange: this.setSumX,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 78\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 79\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"input-group\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 80\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"input-group-prepend\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 81\n      },\n      __self: this\n    }, React.createElement(\"span\", {\n      className: \"input-group-text\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 81\n      },\n      __self: this\n    }, \"X\")), React.createElement(\"input\", {\n      type: \"number\",\n      style: styles,\n      value: this.state.X,\n      onChange: this.setX,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 82\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 83\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      onClick: () => this.runfun(true),\n      className: \"btn btn-danger\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 84\n      },\n      __self: this\n    }, \"sum\")), React.createElement(Collapse, {\n      in: this.state.talang,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86\n      },\n      __self: this\n    }, React.createElement(Table, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86\n      },\n      __self: this\n    }, React.createElement(\"thead\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 87\n      },\n      __self: this\n    }, React.createElement(\"tr\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 88\n      },\n      __self: this\n    }, React.createElement(\"th\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89\n      },\n      __self: this\n    }, \"Iteration\"), React.createElement(\"th\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 90\n      },\n      __self: this\n    }, \"X\"), React.createElement(\"th\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 91\n      },\n      __self: this\n    }, \"ERROR\"))), React.createElement(\"tbody\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 94\n      },\n      __self: this\n    }, this.showfun()))));\n  }\n\n}\n\nexport default NewtonRaphson;","map":{"version":3,"sources":["C:/Users/HP/Desktop/wed/newmer/src/Standard/NewtonRaphson.js"],"names":["React","Table","compile","derivative","Collapse","labelBic","NewtonRaphson","Component","constructor","props","state","SumX","errorX","X","talang","setSumX","bind","setX","event","setState","target","value","runfun","length","fun","showfun","x","sum","diff","xold","parseFloat","scope","ffun","fdif","xnew","error","i","evaluate","push","render","styles","width"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAO,sCAAP;AACA,OAAOC,KAAP,MAAkB,uBAAlB;AACA,SAAQC,OAAR,EAAgBC,UAAhB,QAAiC,QAAjC;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA,IAAIC,QAAQ,GAAC,EAAb;;AAEA,MAAMC,aAAN,SAA4BN,KAAK,CAACO,SAAlC,CAA2C;AACvCC,EAAAA,WAAW,CAACC,KAAD,EAAO;AACd,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAW;AACTC,MAAAA,IAAI,EAAC,EADI;AAETC,MAAAA,MAAM,EAAC,EAFE;AAGTC,MAAAA,CAAC,EAAC,EAHO;AAITC,MAAAA,MAAM,EAAC;AAJE,KAAX;AAMA,SAAKC,OAAL,GAAa,KAAKA,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAAb;AACA,SAAKC,IAAL,GAAU,KAAKA,IAAL,CAAUD,IAAV,CAAe,IAAf,CAAV;AACH;;AACDD,EAAAA,OAAO,CAACG,KAAD,EAAO;AACV,SAAKC,QAAL,CAAc;AAACR,MAAAA,IAAI,EAACO,KAAK,CAACE,MAAN,CAAaC;AAAnB,KAAd;AACH;;AACDJ,EAAAA,IAAI,CAACC,KAAD,EAAO;AACP,SAAKC,QAAL,CAAc;AAACN,MAAAA,CAAC,EAACK,KAAK,CAACE,MAAN,CAAaC;AAAhB,KAAd;AACH;;AACDC,EAAAA,MAAM,CAACJ,KAAD,EAAO;AACT,SAAKC,QAAL,CAAc;AAACL,MAAAA,MAAM,EAACI;AAAR,KAAd;;AACA,QAAGA,KAAH,EAAS;AACLb,MAAAA,QAAQ,CAACkB,MAAT,GAAgB,CAAhB;AACD,WAAKC,GAAL;AACF;AAEJ;;AACDC,EAAAA,OAAO,GAAE;AACL,WAAOpB,QAAP;AACH;;AACDmB,EAAAA,GAAG,GAAE;AACD,QAAIE,CAAC,GAAC,KAAKhB,KAAL,CAAWG,CAAjB;AAAA,QAAmBc,GAAG,GAAC,KAAKjB,KAAL,CAAWC,IAAlC;AAAA,QAAuCa,GAAG,GAAC,EAA3C;AAAA,QAA8CI,IAAI,GAAC,EAAnD;AAAA,QAAsDC,IAAI,GAACC,UAAU,CAACJ,CAAD,CAArE;AAAA,QAAyEK,KAAK,GAAC,EAA/E;AAAA,QAAkFC,IAAI,GAAC,EAAvF;AAAA,QAA0FC,IAAI,GAAC,EAA/F;AAAA,QAAkGC,IAAI,GAAC,EAAvG;AAAA,QAA0GC,KAAK,GAAC,EAAhH;AAAA,QAAmHC,CAAC,GAAC,CAArH;;AACA,WAAM,IAAN,EAAW;AACPZ,MAAAA,GAAG,GAACtB,OAAO,CAACyB,GAAD,CAAX;AACAC,MAAAA,IAAI,GAACzB,UAAU,CAACwB,GAAD,EAAK,GAAL,CAAf;AACAI,MAAAA,KAAK,GAAC;AAACL,QAAAA,CAAC,EAACI,UAAU,CAACD,IAAD;AAAb,OAAN;AACAG,MAAAA,IAAI,GAACR,GAAG,CAACa,QAAJ,CAAaN,KAAb,CAAL;AACAE,MAAAA,IAAI,GAACL,IAAI,CAACS,QAAL,CAAcN,KAAd,CAAL;AACAG,MAAAA,IAAI,GAACL,IAAI,GAAEG,IAAI,GAACC,IAAhB;AACAE,MAAAA,KAAK,GAAE,CAACD,IAAI,GAACL,IAAN,IAAYK,IAAb,GAAmB,GAAzB;AACAL,MAAAA,IAAI,GAACK,IAAL;AACA7B,MAAAA,QAAQ,CAACiC,IAAT,CAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAKF,CAAL,CADU,EAEV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAKP,IAAL,CAFU,EAGV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAKM,KAAL,CAHU,CAAd;AAKAC,MAAAA,CAAC;;AACD,UAAGD,KAAK,GAAC,QAAN,IAAgBC,CAAC,GAAC,GAArB,EAAyB;AACrB;AACH;AACJ;AAEJ;;AACDG,EAAAA,MAAM,GAAE;AACJ,UAAMC,MAAM,GAAC;AAClBC,MAAAA,KAAK,EAAE;AADW,KAAb;AAGA,WACI;AAAK,MAAA,SAAS,EAAC,MAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAO,MAAA,SAAS,EAAC,OAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADJ,EACS;AAAK,MAAA,SAAS,EAAC,oBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBADT,EAEI;AAAK,MAAA,SAAS,EAAC,cAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6/DAFJ,EASI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MATJ,EAUI;AAAK,MAAA,SAAS,EAAC,aAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAK,MAAA,SAAS,EAAC,qBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAqC;AAAM,MAAA,SAAS,EAAC,kBAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAArC,CADJ,EAEQ;AAAO,MAAA,IAAI,EAAC,MAAZ;AAAmB,MAAA,KAAK,EAAED,MAA1B;AAAkC,MAAA,KAAK,EAAE,KAAK9B,KAAL,CAAWC,IAApD;AAA0D,MAAA,QAAQ,EAAE,KAAKI,OAAzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFR,CAVJ,EAac;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAbd,EAcQ;AAAK,MAAA,SAAS,EAAC,aAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAK,MAAA,SAAS,EAAC,qBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAqC;AAAM,MAAA,SAAS,EAAC,kBAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAArC,CADJ,EAEQ;AAAO,MAAA,IAAI,EAAC,QAAZ;AAAqB,MAAA,KAAK,EAAEyB,MAA5B;AAAoC,MAAA,KAAK,EAAE,KAAK9B,KAAL,CAAWG,CAAtD;AAAyD,MAAA,QAAQ,EAAE,KAAKI,IAAxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFR,CAdR,EAiBc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAjBd,EAkBQ;AAAQ,MAAA,OAAO,EAAE,MAAI,KAAKK,MAAL,CAAY,IAAZ,CAArB;AAAwC,MAAA,SAAS,EAAC,gBAAlD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAlBR,CADJ,EAqBI,oBAAC,QAAD;AAAU,MAAA,EAAE,EAAE,KAAKZ,KAAL,CAAWI,MAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAiC,oBAAC,KAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBADA,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAFA,EAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAHA,CADJ,CAD6B,EAQ7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACK,KAAKW,OAAL,EADL,CAR6B,CAAjC,CArBJ,CADJ;AAoCH;;AA5FsC;;AA8F3C,eAAenB,aAAf","sourcesContent":["import React from \"react\"\r\nimport 'bootstrap/dist/css/bootstrap.min.css'\r\nimport Table from 'react-bootstrap/Table'\r\nimport {compile,derivative} from 'mathjs'\r\nimport { Collapse } from \"react-bootstrap\"\r\nvar labelBic=[]\r\n\r\nclass NewtonRaphson extends React.Component{\r\n    constructor(props){\r\n        super(props)\r\n        this.state={\r\n          SumX:\"\",\r\n          errorX:\"\",\r\n          X:\"\",\r\n          talang:false\r\n        }\r\n        this.setSumX=this.setSumX.bind(this);\r\n        this.setX=this.setX.bind(this);\r\n    }\r\n    setSumX(event){\r\n        this.setState({SumX:event.target.value})\r\n    }\r\n    setX(event){\r\n        this.setState({X:event.target.value})\r\n    }\r\n    runfun(event){\r\n        this.setState({talang:event})\r\n        if(event){\r\n            labelBic.length=0\r\n           this.fun()\r\n        }\r\n        \r\n    }\r\n    showfun(){\r\n        return labelBic\r\n    }\r\n    fun(){\r\n        var x=this.state.X,sum=this.state.SumX,fun=\"\",diff=\"\",xold=parseFloat(x),scope=\"\",ffun=\"\",fdif=\"\",xnew=\"\",error=\"\",i=0\r\n        while(true){   \r\n            fun=compile(sum)\r\n            diff=derivative(sum,\"x\")\r\n            scope={x:parseFloat(xold)}\r\n            ffun=fun.evaluate(scope)\r\n            fdif=diff.evaluate(scope)\r\n            xnew=xold-(ffun/fdif)\r\n            error=((xnew-xold)/xnew)*100\r\n            xold=xnew\r\n            labelBic.push(<tr>\r\n                <td>{i}</td>\r\n                <td>{xold}</td>\r\n                <td>{error}</td>\r\n            </tr>)\r\n            i++\r\n            if(error<0.000001||i>100){\r\n                break\r\n            }\r\n        }\r\n        \r\n    }\r\n    render(){\r\n        const styles={\r\n\t\t\twidth: \"250px\"\r\n        }\r\n        return(\r\n            <div className=\"card\">\r\n                <label className=\"alert\">\r\n                    <br/><div className=\"alert alert-danger\">NewtonRaphson</div>\r\n                    <div className=\"Contentnumer\"> The bisection method in mathematics is a root-finding method that repeatedly bisects an interval and then selects a sub-interval in which a root must lie for further processing. It is a very simple and robust method, but it is also relatively slow. Because of this, it is often used to obtain a rough approximation to a solution which is then used as a starting point for more rapidly converging methods.\r\n                                                                    This method is also called the Interval Halving Method, the Binary Search Method, the Dichotomy Method, Robust Root Finding Method and Bolzano’s Method. It’s strategy is to begin with two values of x, say xL and xU, that brackets a root of       f(x) = 0. It determines that the initial values x = xL and x = xU. The method treats the interval distance between the initial values as line segment then successively divides the interval in half and replaces one endpoint with the midpoint so that again the root is bracketed.\r\n                                                                    Note : xL for lower limit\r\n                                                                    xU for upper limit\r\n                                                                    xR for average of upper and lower limit ()\r\n                                                                    At each step, the method divides the interval in two by computing the midpoint xR = (xL + xU) / 2 of the interval and the value of the function f(xR) at that point. Unless xR is itself a root (which is very unlikely, but possible) there are now two possibilities: either f(xL) and f(xR) have opposite signs and bracket a root, or f(xR) and f(xU) have opposite signs and bracket a root. The method selects the subinterval that is a bracket as a new interval to be used in the next step. In this way the interval that contains a zero of f is reduced in width by 50% at each step. The process is continued until the interval is sufficiently small.\r\n                                                                    Explicitly, if f(xL) and f(xR) are opposite signs, then the method sets xR as the new value for xU, and if f(xL) and f(xR) are same signs then the method sets xR as the new xL. (If f(xR)=0 then xR may be taken as the solution and the process stops.)In both cases, the new f(xL) and f(xU) have opposite signs, so the method is applicable to this smaller interval.</div>\r\n                    <br/>\r\n                    <div className=\"input-group\" >\r\n                        <div className=\"input-group-prepend\"><span className=\"input-group-text\">f(x)</span></div>\r\n                            <input type=\"text\" style={styles} value={this.state.SumX} onChange={this.setSumX}/>\r\n                        </div><br/>\r\n                        <div className=\"input-group\">\r\n                            <div className=\"input-group-prepend\"><span className=\"input-group-text\">X</span></div>\r\n                                <input type=\"number\" style={styles} value={this.state.X} onChange={this.setX}/>\r\n                        </div><br/>\r\n                        <button onClick={()=>this.runfun(true)} className=\"btn btn-danger\">sum</ button>\r\n                </label>\r\n                <Collapse in={this.state.talang}><Table>\r\n                    <thead>\r\n                        <tr>\r\n                        <th>Iteration</th>\r\n                        <th>X</th>\r\n                        <th>ERROR</th>\r\n                        </tr>\r\n                    </thead>\r\n                    <tbody>\r\n                        {this.showfun()}\r\n                    </tbody>\r\n                </Table></Collapse>\r\n            </div>\r\n        )\r\n    }\r\n}\r\nexport default NewtonRaphson;"]},"metadata":{},"sourceType":"module"}