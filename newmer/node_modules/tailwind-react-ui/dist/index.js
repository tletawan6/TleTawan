import merge from 'lodash.merge';
import paramCase from 'param-case';
import includes from 'lodash.includes';
import uniqueId from 'lodash.uniqueid';
import { Transition } from 'react-transition-group';
import get from 'lodash.get';
import classnames from 'classnames';
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var defaultTheme = {
  prefix: '',
  radius: 'rounded',
  spacing: {
    zero: 0,
    sm: 2,
    md: 4,
    lg: 8,
    xl: 12
  },
  container: {
    sm: 'xl',
    md: '3xl',
    lg: '4xl'
  },
  text: {
    size: {
      body: ['sm', 'base', 'lg'],
      title: ['lg', 'xl', '2xl', '3xl', '4xl', '5xl']
    },
    family: {
      body: 'sans',
      subtitle: 'sans',
      title: 'sans'
    }
  },
  brandColors: {
    primary: 'blue',
    secondary: 'grey-dark',
    success: 'green',
    danger: 'red',
    warning: 'orange-light',
    info: 'blue-lighter'
  },
  textColors: {
    body: 'grey-darkest',
    link: 'blue-dark',
    linkDark: 'blue-darker',
    emphasis: 'black',
    on: {
      primary: 'white',
      secondary: 'white',
      success: 'white',
      danger: 'white',
      warning: 'black',
      info: 'black',
      dark: 'white'
    }
  },
  surfaceColors: {
    default: 'white',
    dark: 'grey-darker',
    light: 'grey-lightest'
  },
  highlightOffset: 1,
  accentSize: 4,
  breakpoints: {
    sm: '576px',
    md: '768px',
    lg: '992px',
    xl: '1200px'
  }
};

var TailwindTheme = React.createContext(defaultTheme);

var TailwindThemeProvider = function TailwindThemeProvider(_ref) {
  var theme = _ref.theme,
      children = _ref.children;
  var mergedTheme = merge(defaultTheme, theme);
  return React.createElement(TailwindTheme.Provider, {
    value: mergedTheme
  }, children);
};

TailwindThemeProvider.displayName = "TailwindThemeProvider";
TailwindThemeProvider.propTypes = {
  theme: PropTypes.shape({}),
  children: PropTypes.node
};
TailwindThemeProvider.defaultProps = {
  theme: {},
  children: undefined
};

var withTheme = function withTheme(Component) {
  var WithTheme = function WithTheme(props) {
    return React.createElement(TailwindTheme.Consumer, null, function (theme) {
      return React.createElement(Component, _extends({}, props, {
        theme: theme
      }));
    });
  };

  WithTheme.displayName = "WithTheme(" + Component.displayName + ")";
  return WithTheme;
};

var shades = ['lightest', 'lighter', 'light', 'base', 'dark', 'darker', 'darkest'];
var getColorShade = (function (color, offset) {
  if (offset === void 0) {
    offset = 1;
  }

  if (!color) {
    return false;
  }

  if (offset === 0) return color;
  var currentColor = color === 'white' ? ['grey', 'lightest'] : color.split('-');
  var shadeOffset = offset;

  if (color === 'white') {
    if (shadeOffset < 1) return color;
    if (shadeOffset === 1) return 'grey-lightest';
    currentColor = ['grey', 'lightest'];
    if (typeof shadeOffset === 'number') shadeOffset = offset - 1;
  }

  if (currentColor.length === 1) {
    currentColor.push('base');
  }

  if (typeof shadeOffset === 'string') {
    return currentColor[0] + "-" + shadeOffset;
  }

  var shadeIndex = Math.min(Math.max(shades.indexOf(currentColor[1]) + shadeOffset, 0), shades.length - 1);
  var newShade = shades[shadeIndex];
  return "" + currentColor[0] + (newShade === 'base' ? '' : "-" + newShade);
});

var getArray = function getArray(value) {
  return Array.isArray(value) ? value : [value];
};

var splitProp = function splitProp(prop) {
  var utility = prop.substring(prop.indexOf(':') + 1);
  return prop.indexOf(':') !== -1 ? {
    utility: utility,
    variant: prop.substring(0, prop.indexOf(':'))
  } : {
    utility: utility
  };
};

var createClassName = function createClassName(_ref) {
  var utility = _ref.utility,
      value = _ref.value,
      variant = _ref.variant,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === void 0 ? '' : _ref$prefix;
  return "" + (variant ? variant + ":" : '') + prefix + utility + (value !== false && value !== undefined ? "-" + value : '');
};

var tailwindPropToClassName = (function (prop, values, prefix) {
  var propType = typeof values;
  if (!propType) return '';

  var _splitProp = splitProp(prop),
      utility = _splitProp.utility,
      variant = _splitProp.variant;

  if (propType === 'boolean') {
    return createClassName({
      utility: utility,
      variant: variant,
      prefix: prefix
    });
  }

  if (propType === 'object' && !Array.isArray(values)) {
    return Object.keys(values).map(function (key) {
      return createClassName({
        prefix: prefix,
        utility: "" + utility + key,
        variant: variant,
        value: values[key]
      });
    });
  }

  return getArray(values).map(function (value) {
    if (value === false || typeof value === 'undefined') {
      return '';
    }

    if (typeof value === 'boolean') {
      return createClassName({
        utility: utility,
        variant: variant,
        prefix: prefix
      });
    }

    return createClassName({
      prefix: prefix,
      utility: utility,
      variant: variant,
      value: utility !== value ? value : undefined
    });
  }).filter(function (value) {
    return !!value;
  }).join(' ');
});

var display = {
  block: PropTypes.bool,
  hidden: PropTypes.bool,
  inline: PropTypes.bool,
  inlineBlock: PropTypes.bool,
  table: PropTypes.bool,
  tableCell: PropTypes.bool,
  tableRow: PropTypes.bool
};
var floats = {
  clearfix: PropTypes.bool,
  float: PropTypes.oneOf(['none', 'right', 'left'])
};
var overflow = {
  overflow: PropTypes.oneOf(['hidden', 'auto', 'scroll']),
  overflowX: PropTypes.oneOf(['hidden', 'auto', 'scroll']),
  overflowY: PropTypes.oneOf(['hidden', 'auto', 'scroll'])
};
var position = {
  absolute: PropTypes.bool,
  fixed: PropTypes.bool,
  pin: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['t', 'r', 'b', 'l', 'y', 'x', 'none']), PropTypes.array]),
  relative: PropTypes.bool,
  static: PropTypes.bool
};
var zIndex = {
  z: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};
var typography = {
  align: PropTypes.string,
  break: PropTypes.oneOf(['words', 'normal']),
  capitalize: PropTypes.bool,
  font: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  italic: PropTypes.bool,
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  tracking: PropTypes.string,
  leading: PropTypes.string,
  lineThrough: PropTypes.bool,
  lowercase: PropTypes.bool,
  normalCase: PropTypes.bool,
  noUnderline: PropTypes.bool,
  roman: PropTypes.bool,
  truncate: PropTypes.bool,
  underline: PropTypes.bool,
  uppercase: PropTypes.bool,
  whitespace: PropTypes.oneOf(['normal', 'no-wrap', 'pre', 'pre-line', 'pre-wrap'])
};
var backgrounds = {
  bg: PropTypes.oneOfType([PropTypes.string, PropTypes.array])
};
var borders = {
  border: PropTypes.oneOfType([PropTypes.string, PropTypes.bool, PropTypes.array]),
  borderB: PropTypes.number,
  borderL: PropTypes.number,
  borderR: PropTypes.number,
  borderT: PropTypes.number,
  rounded: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedB: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedBl: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedBr: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedL: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedR: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedT: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedTl: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  roundedTr: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])
};
var flexValues = [true, 'row', 'row-reverse', 'col', 'col-reverse', 'no-wrap', 'wrap', 'wrap-reverse', 'initial', 1, 'auto', 'none', 'grow', 'shrink', 'no-grow', 'no-shrink'];
var flexAlignment = ['start', 'center', 'end'];
var flex = {
  content: PropTypes.oneOf(flexAlignment.concat(['between', 'around'])),
  flex: PropTypes.oneOfType([PropTypes.oneOf(flexValues), PropTypes.arrayOf(PropTypes.oneOf(flexValues))]),
  inlineFlex: PropTypes.bool,
  items: PropTypes.oneOf(flexAlignment.concat(['stretch', 'baseline'])),
  self: PropTypes.oneOf(flexAlignment.concat(['auto', 'stretch'])),
  justify: PropTypes.oneOf(flexAlignment.concat(['between', 'around']))
};
var spacingShape = {
  t: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  r: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  b: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  l: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  x: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  y: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
};
var spacing = {
  m: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.shape(spacingShape)]),
  nm: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.shape(spacingShape)]),
  p: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.shape(spacingShape)])
};
var sizing = {
  h: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  maxH: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  minH: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  maxW: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  minW: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  w: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
};
var misc = {
  opacity: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  shadow: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  listReset: PropTypes.bool,
  outline: PropTypes.string,
  appearance: PropTypes.string,
  select: PropTypes.string,
  pointerEvents: PropTypes.string,
  fill: PropTypes.string
};
var plugins = {
  visuallyHidden: PropTypes.bool,
  visuallyHiddenFocusable: PropTypes.bool,
  container: PropTypes.bool
};
var propTypes = _extends({}, display, floats, overflow, position, zIndex, typography, backgrounds, borders, flex, spacing, sizing, misc, plugins);
var propVariants = ['hover', 'focus', 'hocus', 'sm', 'md', 'lg', 'xl'];
var tailwindProps = Object.keys(propTypes).concat(propVariants.reduce(function (variantProps, variant) {
  return variantProps.concat(Object.keys(propTypes).map(function (prop) {
    return prop + "-" + variant;
  }));
}, []));

/* eslint-disable react/destructuring-assignment */

var hasUpperCase = function hasUpperCase(str) {
  return str.toLowerCase() !== str;
};

var getTailwindClassNames = (function (props, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$ignore = _ref.ignore,
      ignore = _ref$ignore === void 0 ? [] : _ref$ignore,
      prefix = _ref.prefix;

  return !!props && Object.keys(props).reduce(function (twClasses, key) {
    if (ignore.includes(key) || props[key] === false || typeof props[key] === 'undefined') return twClasses;
    var type = key.indexOf('-') > 0 ? key.substring(0, key.indexOf('-')) : key;
    var variant = key.indexOf('-') > 0 ? key.substring(key.indexOf('-') + 1) : key;
    if (!tailwindProps.includes(type)) return twClasses;

    if (hasUpperCase(type)) {
      type = paramCase(type);
    }

    if (propVariants.includes(variant)) {
      if (variant === 'hocus') {
        return twClasses.concat([tailwindPropToClassName("hover:" + type, props[key], prefix), tailwindPropToClassName("focus:" + type, props[key], prefix)]);
      }

      return twClasses.concat([tailwindPropToClassName(variant + ":" + type, props[key], prefix)]);
    }

    return twClasses.concat([tailwindPropToClassName(type, props[key], prefix)]);
  }, []);
});

var getAsArray = (function (value) {
  if (!value) return [];
  return Array.isArray(value) ? value : [value];
});

var filterProps = (function (componentProps, filterList) {
  return Object.keys(componentProps).reduce(function (newProps, prop) {
    var _extends2;

    if (includes(filterList, prop)) {
      return newProps;
    }

    return _extends({}, newProps, (_extends2 = {}, _extends2[prop] = componentProps[prop], _extends2));
  }, {});
});

var getUniqueID = (function (prefix) {
  return uniqueId(prefix + "-");
});

var withTheme$1 = function withTheme(Component, _ref) {
  var inState = _ref.inState,
      rest = _objectWithoutPropertiesLoose(_ref, ["inState"]);

  var WithTransition = function WithTransition(componentProps) {
    return React.createElement(Transition, _extends({
      in: get(componentProps, inState),
      timeout: 0
    }, rest), function (state) {
      return React.createElement(Component, _extends({}, componentProps, {
        transition: state
      }));
    });
  };

  WithTransition.displayName = "WithTransition(" + Component.displayName + ")";
  return WithTransition;
};

var withTailwind = function withTailwind(Component, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$ignore = _ref.ignore,
      ignore = _ref$ignore === void 0 ? [] : _ref$ignore;

  var WithTailwind = function WithTailwind(_ref2) {
    var className = _ref2.className,
        props = _objectWithoutPropertiesLoose(_ref2, ["className"]);

    return React.createElement(Component, _extends({}, filterProps(props, tailwindProps.filter(function (prop) {
      return !ignore.includes(prop);
    })), {
      className: classnames([getTailwindClassNames(props, {
        ignore: ignore
      }), className])
    }));
  };

  WithTailwind.displayName = "WithTailwind(" + Component.displayName + ")";
  WithTailwind.propTypes = _extends({
    className: PropTypes.string
  }, propTypes);
  WithTailwind.defaultProps = {
    className: undefined
  };
  return WithTailwind;
};

var useThemeValue = (function (prefix, value, userClassNames) {
  if (userClassNames === void 0) {
    userClassNames = '';
  }

  if (userClassNames.includes(prefix)) {
    return false;
  }

  return tailwindPropToClassName(prefix, value);
});

var Base = function Base(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      className = _ref.className,
      focusable = _ref.focusable,
      innerRef = _ref.innerRef,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children", "className", "focusable", "innerRef"]);

  var Component = is;
  return React.createElement(Component, _extends({}, filterProps(rest, tailwindProps), {
    className: classnames(getTailwindClassNames(_extends({}, rest, {
      'outine-focus': 'none',
      'shadow-focus': 'outline'
    }), {
      prefix: theme.prefix
    }), className),
    ref: innerRef
  }), children);
};

Base.displayName = "Base";
Base.propTypes = _extends({
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  className: PropTypes.string,
  innerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
}, propTypes);
Base.defaultProps = {
  is: 'div',
  children: undefined,
  className: undefined,
  innerRef: undefined
};
var Base$1 = withTheme(Base);

var Box = function Box(_ref) {
  var is = _ref.is,
      children = _ref.children,
      inline = _ref.inline,
      inlineBlock = _ref.inlineBlock,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children", "inline", "inlineBlock"]);

  var el = is === 'div' && (inline || inlineBlock) ? 'span' : is;
  return React.createElement(Base$1, _extends({
    is: el,
    inline: inline,
    inlineBlock: inlineBlock
  }, rest), children);
};

Box.displayName = "Box";
Box.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  inline: PropTypes.bool,
  inlineBlock: PropTypes.bool
};
Box.defaultProps = {
  is: 'div',
  children: undefined,
  inline: false,
  inlineBlock: false
};

var Flex = function Flex(_ref) {
  var is = _ref.is,
      children = _ref.children,
      inline = _ref.inline,
      inlineFlex = _ref.inlineFlex,
      col = _ref.col,
      reverse = _ref.reverse,
      wrap = _ref.wrap,
      wrapReverse = _ref.wrapReverse,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children", "inline", "inlineFlex", "col", "reverse", "wrap", "wrapReverse"]);

  var el = is === 'div' && (inline || inlineFlex) ? 'span' : is;
  var flex = [true];

  if (col) {
    flex.push(reverse ? 'col-reverse' : 'col');
  } else if (reverse) {
    flex.push('row-reverse');
  }

  if (wrap || wrapReverse) {
    flex.push(wrap ? 'wrap' : 'wrap-reverse');
  }

  return React.createElement(Box, _extends({
    is: el,
    flex: flex,
    inlineFlex: inline || inlineFlex
  }, rest), children);
};

Flex.displayName = "Flex";
Flex.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  inline: PropTypes.bool,
  inlineFlex: PropTypes.bool,
  col: PropTypes.bool,
  reverse: PropTypes.bool,
  wrap: PropTypes.bool,
  wrapReverse: PropTypes.bool
};
Flex.defaultProps = {
  is: 'div',
  children: undefined,
  inline: false,
  inlineFlex: false,
  col: false,
  reverse: false,
  wrap: false,
  wrapReverse: false
};

var Image = function Image(_ref) {
  var is = _ref.is,
      children = _ref.children,
      aspectRatio = _ref.aspectRatio,
      bg = _ref.bg,
      w = _ref.w,
      text = _ref.text,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children", "aspectRatio", "bg", "w", "text"]);

  return React.createElement(Box, {
    relative: true,
    w: w,
    text: text
  }, React.createElement(Box, {
    bg: bg,
    style: {
      paddingBottom: 100 / aspectRatio + "%"
    }
  }), React.createElement(Base$1, _extends({
    is: is,
    absolute: true,
    pin: true,
    w: "full"
  }, rest)), children && React.createElement(Box, {
    absolute: true,
    pin: true,
    flex: true,
    items: "end"
  }, children));
};

Image.displayName = "Image";
Image.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  aspectRatio: PropTypes.number,
  bg: propTypes.bg,
  w: propTypes.w,
  text: propTypes.text
};
Image.defaultProps = {
  is: 'img',
  aspectRatio: 1,
  children: undefined,
  bg: 'grey-light',
  w: 'full',
  text: undefined
};

var Text = function Text(_ref) {
  var children = _ref.children,
      is = _ref.is,
      bold = _ref.bold,
      font = _ref.font,
      text = _ref.text,
      color = _ref.color,
      size = _ref.size,
      weight = _ref.weight,
      tight = _ref.tight,
      loose = _ref.loose,
      leading = _ref.leading,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "is", "bold", "font", "text", "color", "size", "weight", "tight", "loose", "leading"]);

  var fontValue = getAsArray(font).concat([bold ? 'bold' : weight]);
  var textValue = getAsArray(text).concat([color, size]);
  var leadingValue = leading;

  if (tight || loose) {
    leadingValue = tight ? 'tight' : 'loose';
  }

  return React.createElement(Base$1, _extends({
    is: is,
    font: fontValue.filter(function (value) {
      return !!value;
    }),
    text: textValue.filter(function (value) {
      return !!value;
    }),
    leading: leadingValue
  }, rest), children);
};

Text.displayName = "Text";
Text.propTypes = {
  children: PropTypes.node,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  font: propTypes.font,
  text: propTypes.text,
  bold: PropTypes.bool,
  color: PropTypes.string,
  size: PropTypes.string,
  weight: PropTypes.string,
  leading: propTypes.leading,
  tight: PropTypes.bool,
  loose: PropTypes.bool
};
Text.defaultProps = {
  children: undefined,
  is: 'span',
  font: undefined,
  text: undefined,
  bold: false,
  color: undefined,
  size: undefined,
  weight: undefined,
  leading: 'normal',
  tight: false,
  loose: false
};

var focusableElements = ['input', 'select', 'textarea', 'button', 'a'];

var Touchable =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(Touchable, _PureComponent);

  function Touchable(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = Touchable.prototype;

  _proto.handleKeyPress = function handleKeyPress(e) {
    var onTouch = this.props.onTouch;

    if (onTouch && (e.key && (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') || e.keyCode && (e.keyCode === 13 || e.keyCode === 32))) {
      e.preventDefault();
      onTouch(e);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        is = _this$props.is,
        children = _this$props.children,
        tabIndex = _this$props.tabIndex,
        disabled = _this$props.disabled,
        onTouch = _this$props.onTouch,
        rest = _objectWithoutPropertiesLoose(_this$props, ["is", "children", "tabIndex", "disabled", "onTouch"]);

    var isSemantic = focusableElements.includes(is);
    return React.createElement(Base$1, _extends({
      is: is,
      select: "none",
      cursor: "pointer",
      pointerEvents: disabled ? 'none' : undefined,
      focusable: true,
      role: !isSemantic ? 'button' : undefined,
      tabIndex: tabIndex || (!isSemantic && !disabled ? 0 : undefined),
      opacity: disabled ? 50 : undefined,
      disabled: disabled,
      "aria-disabled": disabled || undefined,
      onClick: onTouch,
      onKeyPress: !isSemantic && !disabled ? this.handleKeyPress : undefined
    }, rest), children);
  };

  return Touchable;
}(PureComponent);

Touchable.displayName = "Touchable";
Touchable.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  disabled: PropTypes.bool,
  tabIndex: PropTypes.number,
  onTouch: PropTypes.func
};
Touchable.defaultProps = {
  is: 'button',
  children: undefined,
  disabled: false,
  tabIndex: undefined,
  onTouch: undefined
};

var Button = function Button(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      color = _ref.color,
      type = _ref.type,
      buttonStyle = _ref.buttonStyle,
      disabled = _ref.disabled,
      large = _ref.large,
      small = _ref.small,
      fullWidth = _ref.fullWidth,
      bg = _ref.bg,
      text = _ref.text,
      border = _ref.border,
      brand = _ref.brand,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children", "color", "type", "buttonStyle", "disabled", "large", "small", "fullWidth", "bg", "text", "border", "brand"]);

  var props = {
    border: [true, 'transparent'],
    leading: 'tight',
    p: {
      x: theme.spacing.md,
      y: theme.spacing.sm
    },
    rounded: theme.radius,
    noUnderline: true
  };

  if (large) {
    props.p = {
      x: theme.spacing.lg,
      y: theme.spacing.md
    };
  } else if (small) {
    props.p = {
      x: theme.spacing.sm,
      y: theme.spacing.sm / 2
    };
  }

  switch (buttonStyle) {
    case 'fill':
      props.bg = brand ? theme.brandColors[brand] : bg;
      props.text = brand ? theme.textColors.on[brand] : text;
      props['bg-hocus'] = getColorShade(brand ? theme.brandColors[brand] : bg, theme.highlightOffset);
      break;

    case 'outline':
      // eslint-disable-next-line react/prop-types
      props.border.push(brand ? theme.brandColors[brand] : border);
      props.text = brand ? theme.brandColors[brand] : border;
      props['bg-hocus'] = brand ? theme.brandColors[brand] : border;
      props['text-hocus'] = brand ? theme.textColors.on[brand] : text;
      break;

    case 'text':
      props.text = brand ? theme.brandColors[brand] : text;
      props['bg-hocus'] = "" + getColorShade(brand ? theme.brandColors[brand] : text, 'lightest');
      break;

    case 'link':
      props.rounded = undefined;
      props.noUnderline = undefined;
      props.leading = 'normal';
      props.p = 0;
      props.underline = true;
      props.text = brand ? theme.brandColors[brand] : text;
      props['text-hocus'] = getColorShade(brand ? theme.brandColors[brand] : text, theme.highlightOffset);
      break;

    default:
      break;
  }

  if (is === 'button') {
    props.type = type;
  } else {
    props.role = 'button';
  }

  if (disabled) {
    props.opacity = 50;
  }

  if (fullWidth) {
    props.w = 'full';
  }

  return React.createElement(Touchable, _extends({
    is: is,
    inlineBlock: true
  }, props, rest), children);
};

Button.displayName = "Button";
Button.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  color: PropTypes.string,
  type: PropTypes.string,
  buttonStyle: PropTypes.oneOf(['fill', 'outline', 'text', 'link']),
  disabled: PropTypes.bool,
  large: PropTypes.bool,
  small: PropTypes.bool,
  fullWidth: PropTypes.bool,
  brand: PropTypes.string,
  bg: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  border: PropTypes.oneOfType([PropTypes.string, PropTypes.array])
};
Button.defaultProps = {
  is: 'button',
  children: undefined,
  color: 'primary',
  type: 'button',
  buttonStyle: 'fill',
  disabled: false,
  large: false,
  small: false,
  fullWidth: false,
  brand: undefined,
  bg: undefined,
  text: undefined,
  border: undefined
};
var Button$1 = withTheme(Button);

/**
 * @see See [Button](#button-2) for API. Sets `buttonStyle` prop to `fill`.
 */

var FillButton = function FillButton(props) {
  return React.createElement(Button$1, _extends({}, props, {
    buttonStyle: "fill"
  }));
};

FillButton.displayName = "FillButton";

/**
 * @see See [Button](#button-2) for API. Sets `buttonStyle` prop to `outline`.
 */

var OutlineButton = function OutlineButton(props) {
  return React.createElement(Button$1, _extends({}, props, {
    buttonStyle: "outline"
  }));
};

OutlineButton.displayName = "OutlineButton";

/**
 * @see See [Button](#button-2) for API. Sets `buttonStyle` prop to `text`.
 */

var TextButton = function TextButton(props) {
  return React.createElement(Button$1, _extends({}, props, {
    buttonStyle: "text"
  }));
};

TextButton.displayName = "TextButton";

/**
 * @see See [Button](#button-2) for API. Sets `buttonStyle` prop to `link`.
 */

var LinkButton = function LinkButton(props) {
  return React.createElement(Button$1, _extends({}, props, {
    buttonStyle: "link"
  }));
};

LinkButton.displayName = "LinkButton";

var Card = function Card(_ref) {
  var is = _ref.is,
      children = _ref.children,
      theme = _ref.theme,
      surface = _ref.surface,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children", "theme", "surface"]);

  return React.createElement(Box, _extends({
    is: is,
    overflow: "hidden",
    rounded: theme.radius,
    bg: theme.surfaceColors[surface] || theme.brandColors[surface],
    text: surface !== 'default' ? theme.textColors.on[surface] : undefined
  }, rest), children);
};

Card.displayName = "Card";
Card.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  theme: PropTypes.shape({}).isRequired,
  children: PropTypes.node,
  surface: PropTypes.string
};
Card.defaultProps = {
  is: 'section',
  children: undefined,
  surface: 'default'
};
var Card$1 = withTheme(Card);

var CardBody = function CardBody(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children"]);

  return React.createElement(Box, _extends({
    is: is,
    p: theme.spacing.md
  }, rest), children);
};

CardBody.displayName = "CardBody";
CardBody.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node
};
CardBody.defaultProps = {
  is: 'div',
  children: undefined
};
var CardBody$1 = withTheme(CardBody);

var CardFooter = function CardFooter(_ref) {
  var is = _ref.is,
      children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children"]);

  return React.createElement(Flex, _extends({
    is: is,
    reverse: true,
    items: "end"
  }, rest), React.Children.map(children, function (child) {
    return React.cloneElement(child, {
      rounded: 'none'
    });
  }));
};

CardFooter.displayName = "CardFooter";
CardFooter.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node
};
CardFooter.defaultProps = {
  is: 'div',
  children: undefined
};

var Container = function Container(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      leftAlign = _ref.leftAlign,
      padding = _ref.padding,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children", "leftAlign", "padding"]);

  return React.createElement(Box, _extends({
    is: is,
    m: !leftAlign ? {
      x: 'auto'
    } : undefined,
    p: padding ? {
      x: theme.spacing.md
    } : undefined,
    container: true
  }, rest), children);
};

Container.displayName = "Container";
Container.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  leftAlign: PropTypes.bool,
  padding: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])
};
Container.defaultProps = {
  is: 'div',
  children: undefined,
  leftAlign: false,
  padding: false
};
var Container$1 = withTheme(Container);

var Title = function Title(_ref) {
  var theme = _ref.theme,
      children = _ref.children,
      is = _ref.is,
      size = _ref.size,
      subtitle = _ref.subtitle,
      flush = _ref.flush,
      level = _ref.level,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "children", "is", "size", "subtitle", "flush", "level"]);

  var hLevel = level || Math.max(7 - size, 1);
  var element = is || "h" + hLevel;
  var ariaProps = {};

  if (!subtitle && element !== 'string' && !/h[1-6]/i.test(element)) {
    ariaProps = {
      role: 'heading',
      'aria-level': hLevel
    };
  }

  return React.createElement(Text, _extends({
    is: element
  }, ariaProps, {
    leading: "tight",
    font: [theme.text.family[subtitle ? 'subtitle' : 'title'], subtitle ? 'medium' : 'bold'],
    text: [theme.text.size.title[size - 1], subtitle ? theme.textColors.body : theme.textColors.emphasis],
    m: !flush ? {
      b: theme.spacing.md
    } : undefined
  }, rest), children);
};

Title.displayName = "Title";
Title.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  children: PropTypes.node,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  size: PropTypes.number,
  subtitle: PropTypes.bool,
  flush: PropTypes.bool,
  level: PropTypes.number
};
Title.defaultProps = {
  children: undefined,
  is: undefined,
  size: 4,
  subtitle: false,
  flush: false,
  level: undefined
};
var Title$1 = withTheme(Title);

/**
 * @see See [Title](#title) for prop type definitions. Sets `subtitle` to `true`.
 */

var Subtitle = function Subtitle(props) {
  return React.createElement(Title$1, _extends({}, props, {
    subtitle: true
  }));
};

Subtitle.displayName = "Subtitle";

var Paragraph = function Paragraph(_ref) {
  var theme = _ref.theme,
      children = _ref.children,
      is = _ref.is,
      size = _ref.size,
      lead = _ref.lead,
      brand = _ref.brand,
      paragraph = _ref.paragraph,
      text = _ref.text,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "children", "is", "size", "lead", "brand", "paragraph", "text"]);

  return React.createElement(Text, _extends({
    is: is,
    text: [(size || lead) && theme.text.size.body[(lead ? theme.text.size.body.length : size) - 1]].concat(getAsArray(text)),
    m: {
      b: theme.spacing.md
    }
  }, rest), children);
};

Paragraph.displayName = "Paragraph";
Paragraph.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  children: PropTypes.node,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  size: PropTypes.number,
  lead: PropTypes.bool,
  brand: PropTypes.bool,
  paragraph: PropTypes.bool,
  text: propTypes.text
};
Paragraph.defaultProps = {
  children: undefined,
  is: 'p',
  size: undefined,
  paragraph: false,
  lead: false,
  brand: false,
  text: undefined
};
var Paragraph$1 = withTheme(Paragraph);

var BrandText = function BrandText(_ref) {
  var theme = _ref.theme,
      textOnly = _ref.textOnly,
      type = _ref.type,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "textOnly", "type"]);

  var alertProps = !textOnly ? {
    bg: getColorShade(theme.brandColors[type], 'lightest'),
    border: ["l-" + theme.accentSize, theme.brandColors[type]],
    p: {
      x: theme.spacing.md,
      y: theme.spacing.sm
    },
    text: theme.textColors.body,
    rounded: 'r'
  } : {};
  return React.createElement(Paragraph$1, _extends({}, rest, {
    brand: true,
    rounded: theme.radius,
    text: getColorShade(theme.brandColors[type], 1),
    m: {
      b: theme.spacing.sm
    }
  }, alertProps));
};

BrandText.displayName = "BrandText";
BrandText.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  textOnly: PropTypes.bool,
  type: PropTypes.string.isRequired
};
BrandText.defaultProps = {
  is: 'p',
  textOnly: false
};
var BrandText$1 = withTheme(BrandText);

/**
 * @see See [BrandText](#brandtext) for API. Sets `type` prop to `danger`.
 */

var DangerText = function DangerText(props) {
  return React.createElement(BrandText$1, _extends({}, props, {
    type: "danger"
  }));
};

DangerText.displayName = "DangerText";

/**
 * @see See [BrandText](#brandtext) for API. Sets `type` prop to `info`.
 */

var InfoText = function InfoText(props) {
  return React.createElement(BrandText$1, _extends({}, props, {
    type: "info"
  }));
};

InfoText.displayName = "InfoText";

/**
 * @see See [BrandText](#brandtext) for API. Sets `type` prop to `warning`.
 */

var WarningText = function WarningText(props) {
  return React.createElement(BrandText$1, _extends({}, props, {
    type: "warning"
  }));
};

WarningText.displayName = "WarningText";

var ContentTitle = function ContentTitle(_ref) {
  var id = _ref.content.id,
      visuallyHidden = _ref.visuallyHidden,
      rest = _objectWithoutPropertiesLoose(_ref, ["content", "visuallyHidden"]);

  return React.createElement(Title$1, _extends({
    id: id,
    visuallyHidden: visuallyHidden
  }, rest));
};

ContentTitle.displayName = "ContentTitle";
ContentTitle.propTypes = {
  content: PropTypes.shape({
    id: PropTypes.string
  }),
  visuallyHidden: PropTypes.bool
};
ContentTitle.defaultProps = {
  content: {},
  visuallyHidden: false
};

var ContentBlock =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(ContentBlock, _PureComponent);

  function ContentBlock(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.id = getUniqueID('content');
    return _this;
  }

  var _proto = ContentBlock.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        theme = _this$props.theme,
        is = _this$props.is,
        children = _this$props.children,
        rest = _objectWithoutPropertiesLoose(_this$props, ["theme", "is", "children"]);

    return React.createElement(Box, _extends({
      is: is,
      p: theme.spacing.md,
      "aria-labelledby": this.id
    }, rest), React.Children.map(children, function (child, index) {
      if (child.type === ContentTitle) {
        return React.cloneElement(child, {
          content: {
            id: _this2.id
          }
        });
      }

      if (index === React.Children.count(children) - 1) {
        return React.cloneElement(child, {
          m: {
            b: 0
          }
        });
      }

      return child;
    }));
  };

  return ContentBlock;
}(PureComponent);

ContentBlock.displayName = "ContentBlock";
ContentBlock.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node
};
ContentBlock.defaultProps = {
  is: 'section',
  children: undefined
};
var ContentBlock$1 = withTheme(ContentBlock);

var Article = function Article(_ref) {
  var is = _ref.is,
      rest = _objectWithoutPropertiesLoose(_ref, ["is"]);

  return React.createElement(ContentBlock$1, _extends({
    is: is
  }, rest));
};

Article.displayName = "Article";
Article.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object])
};
Article.defaultProps = {
  is: 'article'
};

var Aside = function Aside(_ref) {
  var is = _ref.is,
      rest = _objectWithoutPropertiesLoose(_ref, ["is"]);

  return React.createElement(ContentBlock$1, _extends({
    is: is
  }, rest));
};

Aside.displayName = "Aside";
Aside.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object])
};
Aside.defaultProps = {
  is: 'aside'
};

var Section = function Section(_ref) {
  var is = _ref.is,
      rest = _objectWithoutPropertiesLoose(_ref, ["is"]);

  return React.createElement(ContentBlock$1, _extends({
    is: is
  }, rest));
};

Section.displayName = "Section";
Section.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object])
};
Section.defaultProps = {
  is: 'section'
};

var Footer = function Footer(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children"]);

  return React.createElement(Box, _extends({
    is: is,
    role: "contentinfo",
    p: {
      t: theme.spacing.lg,
      b: theme.spacing.xl
    },
    bg: theme.brandColors.secondary,
    text: theme.textColors.on.secondary
  }, rest), React.createElement(Container$1, {
    padding: true
  }, children));
};

Footer.displayName = "Footer";
Footer.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node
};
Footer.defaultProps = {
  is: 'footer',
  children: undefined
};
var Footer$1 = withTheme(Footer);

/**
 * @see Renders as [DangerText](#dangertext) component by default
 */

var ErrorText = function ErrorText(_ref) {
  var errorId = _ref.field.errorId,
      is = _ref.is,
      rest = _objectWithoutPropertiesLoose(_ref, ["field", "is"]);

  return React.createElement(Box, _extends({
    is: is,
    id: errorId,
    "aria-live": "assertive"
  }, rest));
};

ErrorText.displayName = "ErrorText";
ErrorText.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  field: PropTypes.shape({
    errorId: PropTypes.string
  }),
  size: PropTypes.number
};
ErrorText.defaultProps = {
  is: DangerText,
  field: {},
  size: 1
};

var Field =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(Field, _PureComponent);

  function Field(props) {
    var _this;

    var id = props.id;
    _this = _PureComponent.call(this, props) || this;
    _this.id = id || getUniqueID('field');
    return _this;
  }

  var _proto = Field.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        theme = _this$props.theme,
        is = _this$props.is,
        children = _this$props.children,
        className = _this$props.className,
        hasHelp = _this$props.hasHelp,
        hasError = _this$props.hasError,
        disabled = _this$props.disabled,
        optionList = _this$props.optionList,
        rest = _objectWithoutPropertiesLoose(_this$props, ["theme", "is", "children", "className", "hasHelp", "hasError", "disabled", "optionList"]);

    var fieldProps = {
      inputId: this.id + "-input",
      helpId: hasHelp ? this.id + "-help" : undefined,
      errorId: hasError ? this.id + "-error" : undefined,
      labelId: optionList ? this.id + "-label" : undefined,
      invalid: hasError,
      disabled: disabled
    };
    return React.createElement(Box, _extends({
      is: is,
      id: this.id,
      m: {
        b: theme.spacing.md
      },
      maxW: "sm"
    }, filterProps(rest, ['id'])), React.Children.map(children, function (child) {
      return React.cloneElement(child, {
        field: fieldProps
      });
    }));
  };

  return Field;
}(PureComponent);

Field.displayName = "Field";
Field.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  className: PropTypes.string,
  hasHelp: PropTypes.bool,
  hasError: PropTypes.bool,
  disabled: PropTypes.bool,
  id: PropTypes.string,
  optionList: PropTypes.bool
};
Field.defaultProps = {
  is: 'div',
  children: undefined,
  className: undefined,
  hasHelp: false,
  hasError: false,
  disabled: false,
  id: undefined,
  optionList: false
};
var Field$1 = withTheme(Field);

/**
 * @see Renders as [InfoText](#infotext) component by default
 */

var HelpText = function HelpText(_ref) {
  var is = _ref.is,
      helpId = _ref.field.helpId,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "field"]);

  return React.createElement(Box, _extends({
    is: is,
    id: helpId
  }, rest));
};

HelpText.displayName = "HelpText";
HelpText.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  field: PropTypes.shape({
    helpId: PropTypes.string
  }),
  size: PropTypes.number
};
HelpText.defaultProps = {
  is: InfoText,
  field: {},
  size: 1
};

var Label = function Label(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      id = _ref.id,
      _ref$field = _ref.field,
      labelId = _ref$field.labelId,
      inputId = _ref$field.inputId,
      disabled = _ref$field.disabled,
      children = _ref.children,
      htmlFor = _ref.htmlFor,
      optionList = _ref.optionList,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "id", "field", "children", "htmlFor", "optionList"]);

  return React.createElement(Text, _extends({
    is: is,
    id: labelId || id,
    inlineBlock: true,
    htmlFor: !optionList ? inputId || htmlFor : undefined,
    m: {
      b: theme.spacing.sm
    },
    opacity: disabled ? 50 : undefined,
    weight: "bold"
  }, rest), children);
};

Label.displayName = "Label";
Label.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  id: PropTypes.string,
  field: PropTypes.shape({
    inputId: PropTypes.string,
    disabled: PropTypes.bool
  }),
  children: PropTypes.node,
  htmlFor: PropTypes.string,
  optionList: PropTypes.bool
};
Label.defaultProps = {
  is: 'label',
  id: undefined,
  field: {
    disabled: false
  },
  children: undefined,
  htmlFor: undefined,
  optionList: false
};
var Label$1 = withTheme(Label);

var ExpandMore = function ExpandMore(props) {
  return React.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, props), React.createElement("path", {
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }), React.createElement("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }));
};

ExpandMore.displayName = "ExpandMore";

var Select = function Select(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      field = _ref.field,
      children = _ref.children,
      id = _ref.id,
      name = _ref.name,
      type = _ref.type,
      disabled = _ref.disabled,
      readOnly = _ref.readOnly,
      invalid = _ref.invalid,
      placeholder = _ref.placeholder,
      options = _ref.options,
      icon = _ref.icon,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "field", "children", "id", "name", "type", "disabled", "readOnly", "invalid", "placeholder", "options", "icon"]);

  var describedBy = [field.errorId, field.helpId].filter(function (by) {
    return by;
  });
  var isInvalid = field.invalid || invalid;
  return React.createElement(Box, {
    relative: true,
    m: {
      b: theme.spacing.sm
    }
  }, React.createElement(Touchable, _extends({
    is: is,
    appearance: "none",
    bg: "white",
    rounded: theme.radius,
    text: theme.textColors.body,
    p: {
      l: theme.spacing.md,
      r: theme.spacing.lg,
      y: theme.spacing.sm
    },
    border: !isInvalid ? true : [true, theme.brandColors.danger],
    w: "full",
    leading: "tight",
    id: field.inputId || id || name,
    name: name,
    type: type,
    disabled: field.disabled || disabled,
    readOnly: readOnly,
    "aria-invalid": isInvalid || undefined,
    "aria-describedby": describedBy.length ? describedBy.join(' ') : undefined
  }, rest), !!placeholder && React.createElement("option", {
    value: ""
  }, placeholder), options.map(function (option) {
    return React.createElement("option", {
      key: name + "-" + option.value,
      value: option.value
    }, option.label);
  })), React.createElement(Box, {
    absolute: true,
    pin: ['y', 'r'],
    flex: true,
    items: "center",
    p: {
      x: theme.spacing.sm
    },
    pointerEvents: "none"
  }, React.createElement(Box, {
    is: icon,
    h: 6,
    w: 6
  })));
};

Select.displayName = "Select";
Select.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  field: PropTypes.shape({
    inputId: PropTypes.string,
    invalid: PropTypes.bool,
    disabled: PropTypes.bool
  }),
  children: PropTypes.node,
  id: PropTypes.string,
  name: PropTypes.string.isRequired,
  type: PropTypes.string,
  disabled: PropTypes.bool,
  readOnly: PropTypes.bool,
  invalid: PropTypes.bool,
  placeholder: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  icon: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  options: PropTypes.arrayOf(PropTypes.shape({
    label: PropTypes.string,
    value: PropTypes.string
  }))
};
Select.defaultProps = {
  is: 'select',
  field: {},
  children: undefined,
  id: undefined,
  type: 'text',
  disabled: false,
  readOnly: false,
  invalid: false,
  placeholder: 'Please select',
  icon: ExpandMore,
  options: []
};
var Select$1 = withTheme(Select);

var TextInput = function TextInput(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      field = _ref.field,
      children = _ref.children,
      id = _ref.id,
      name = _ref.name,
      type = _ref.type,
      disabled = _ref.disabled,
      readOnly = _ref.readOnly,
      invalid = _ref.invalid,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "field", "children", "id", "name", "type", "disabled", "readOnly", "invalid"]);

  var describedBy = [field.errorId, field.helpId].filter(function (by) {
    return by;
  });
  var isInvalid = field.invalid || invalid;
  return React.createElement(Touchable, _extends({
    is: is,
    appearance: "none",
    bg: "white",
    rounded: theme.radius,
    text: theme.textColors.body,
    p: {
      x: theme.spacing.md,
      y: theme.spacing.sm
    },
    m: {
      b: theme.spacing.sm
    },
    border: !isInvalid ? true : [true, theme.brandColors.danger],
    w: "full",
    leading: "tight",
    id: field.inputId || id || name,
    name: name,
    type: type,
    disabled: field.disabled || disabled,
    readOnly: readOnly,
    "aria-invalid": isInvalid || undefined,
    "aria-describedby": describedBy.length ? describedBy.join(' ') : undefined
  }, rest));
};

TextInput.displayName = "TextInput";
TextInput.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  field: PropTypes.shape({
    inputId: PropTypes.string,
    invalid: PropTypes.bool,
    disabled: PropTypes.bool
  }),
  children: PropTypes.node,
  id: PropTypes.string,
  name: PropTypes.string.isRequired,
  type: PropTypes.string,
  disabled: PropTypes.bool,
  readOnly: PropTypes.bool,
  invalid: PropTypes.bool
};
TextInput.defaultProps = {
  is: 'input',
  field: {},
  children: undefined,
  id: undefined,
  type: 'text',
  disabled: false,
  readOnly: false,
  invalid: false
};
var TextInput$1 = withTheme(TextInput);

var OptionInput =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(OptionInput, _PureComponent);

  function OptionInput(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    var defaultChecked = props.defaultChecked,
        checked = props.checked;
    _this.state = {
      checked: defaultChecked || !!checked
    };
    _this.inputRef = null;
    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleUpdate = _this.handleUpdate.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = OptionInput.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    this.handleUpdate(prevProps);
  };

  _proto.handleChange = function handleChange(e) {
    var _this$props = this.props,
        checkbox = _this$props.checkbox,
        onChange = _this$props.onChange,
        checked = _this$props.checked;

    if (checked === undefined) {
      this.setState(function (_ref) {
        var checkedState = _ref.checked;
        return {
          checked: checkbox ? !checkedState : true
        };
      });
    }

    if (onChange) onChange(_extends({}, e, {
      target: this.inputRef.current
    }));
    e.preventDefault();
  };

  _proto.handleUpdate = function handleUpdate() {
    var checked = this.props.checked;
    var checkedState = this.state.checked;

    if (checked !== undefined && checked !== checkedState) {
      this.setState({
        checked: checked
      });
    }
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        theme = _this$props2.theme,
        name = _this$props2.name,
        value = _this$props2.value,
        label = _this$props2.label,
        hideLabel = _this$props2.hideLabel,
        checkbox = _this$props2.checkbox,
        id = _this$props2.id,
        rest = _objectWithoutPropertiesLoose(_this$props2, ["theme", "name", "value", "label", "hideLabel", "checkbox", "id"]);

    var checked = this.state.checked;
    this.inputRef = React.createRef();
    return React.createElement(Touchable, _extends({
      is: Label$1,
      flex: true,
      items: "center",
      onTouch: this.handleChange
    }, rest), React.createElement(Box, {
      is: "input",
      id: id,
      visuallyHidden: true,
      name: name,
      type: checkbox ? 'checkbox' : 'radio',
      value: value,
      checked: checked,
      tabIndex: "-1",
      innerRef: this.inputRef,
      onChange: function onChange() {}
    }), React.createElement(Flex, {
      items: "center",
      justify: "center",
      inlineBlock: true,
      rounded: checkbox ? theme.radius : 'full',
      h: 4,
      w: 4,
      border: [true, checked ? theme.brandColors.primary : false].filter(function (prop) {
        return !!prop;
      }),
      bg: checkbox && checked ? theme.brandColors.primary : undefined,
      m: {
        r: theme.spacing.sm
      }
    }, checked && (checkbox ? React.createElement(Box, {
      is: "svg",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      h: 3,
      w: 3,
      text: "white",
      fill: "current"
    }, React.createElement("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), React.createElement("path", {
      d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
    })) : React.createElement(Box, {
      inlineBlock: true,
      rounded: "full",
      h: 2,
      w: 2,
      bg: theme.brandColors.primary
    }))), React.createElement(Box, {
      inlineBlock: true,
      visuallyHidden: hideLabel,
      leading: "tight",
      font: "normal"
    }, label));
  };

  return OptionInput;
}(PureComponent);

OptionInput.displayName = "OptionInput";
OptionInput.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  name: PropTypes.string.isRequired,
  value: PropTypes.string.isRequired,
  label: PropTypes.string.isRequired,
  hideLabel: PropTypes.bool,
  defaultChecked: PropTypes.bool,
  checked: PropTypes.bool,
  onChange: PropTypes.func,
  checkbox: PropTypes.bool,
  id: PropTypes.string
};
OptionInput.defaultProps = {
  hideLabel: false,
  defaultChecked: undefined,
  checked: undefined,
  onChange: undefined,
  checkbox: false,
  id: undefined
};
var OptionInput$1 = withTheme(OptionInput);

var Radio = function Radio(props) {
  return React.createElement(OptionInput$1, _extends({}, props, {
    checkbox: false
  }));
};

Radio.displayName = "Radio";

var Checkbox = function Checkbox(props) {
  return React.createElement(OptionInput$1, _extends({}, props, {
    checkbox: true
  }));
};

Checkbox.displayName = "Checkbox";

var List = function List(_ref) {
  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      padding = _ref.padding,
      reset = _ref.reset,
      inline = _ref.inline,
      justified = _ref.justified,
      fullWidth = _ref.fullWidth,
      ordered = _ref.ordered,
      listItemIs = _ref.listItemIs,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children", "padding", "reset", "inline", "justified", "fullWidth", "ordered", "listItemIs"]);

  return React.createElement(Box, _extends({
    is: ordered ? 'ol' : is,
    m: {
      b: theme.spacing.md
    },
    flex: justified || fullWidth || (inline ? [true, 'wrap'].concat(rest.flex) : rest.flex),
    justify: justified ? 'between' : undefined,
    listReset: reset || inline || justified || fullWidth
  }, rest), React.Children.map(children, function (child) {
    return child && React.createElement(Box, {
      is: listItemIs,
      m: {
        b: padding && !justified && !fullWidth && theme.spacing.sm,
        r: inline && theme.spacing.sm
      },
      flex: fullWidth ? 'grow' : undefined
    }, child);
  }));
};

List.displayName = "List";
List.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  padding: PropTypes.bool,
  reset: PropTypes.bool,
  inline: PropTypes.bool,
  justified: PropTypes.bool,
  fullWidth: PropTypes.bool,
  ordered: PropTypes.bool,
  listItemIs: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object])
};
List.defaultProps = {
  is: 'ul',
  children: undefined,
  padding: false,
  reset: false,
  inline: false,
  justified: false,
  fullWidth: false,
  ordered: false,
  listItemIs: 'li'
};
var List$1 = withTheme(List);

var OptionList =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(OptionList, _PureComponent);

  function OptionList(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.state = {
      checked: []
    };
    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = OptionList.prototype;

  _proto.handleChange = function handleChange(e) {
    var checkbox = this.props.checkbox;
    var checked = this.state.checked;
    var value = e.target.value;

    if (checkbox) {
      return this.setState({
        checked: checked.includes(value) ? checked.filter(function (checkedVal) {
          return checkedVal !== value;
        }) : checked.concat([value])
      });
    }

    return this.setState({
      checked: [e.target.value]
    });
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        theme = _this$props.theme,
        children = _this$props.children,
        name = _this$props.name,
        checkbox = _this$props.checkbox,
        field = _this$props.field,
        invalid = _this$props.invalid,
        rest = _objectWithoutPropertiesLoose(_this$props, ["theme", "children", "name", "checkbox", "field", "invalid"]);

    var checked = this.state.checked;
    var describedBy = [field.labelId, field.errorId, field.helpId].filter(function (by) {
      return by;
    });
    var isInvalid = field.invalid || invalid;
    return React.createElement(List$1, _extends({
      reset: true,
      m: {
        b: 0
      }
    }, rest), React.Children.map(children, function (child) {
      var value = child.props && child.props.value;
      return React.cloneElement(child, {
        id: field.inputId + "-" + value,
        name: checkbox ? name + "[]" : name,
        checked: checked.includes(value),
        onChange: _this2.handleChange,
        'aria-invalid': isInvalid || undefined,
        'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined
      });
    }));
  };

  return OptionList;
}(PureComponent);

OptionList.displayName = "OptionList";
OptionList.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  children: PropTypes.node,
  name: PropTypes.string.isRequired,
  field: PropTypes.shape({
    inputId: PropTypes.string,
    invalid: PropTypes.bool,
    disabled: PropTypes.bool
  }),
  checkbox: PropTypes.bool,
  invalid: PropTypes.bool
};
OptionList.defaultProps = {
  children: undefined,
  checkbox: false,
  field: {},
  invalid: false
};
var OptionList$1 = withTheme(OptionList);

var getWidthProps = function getWidthProps(width) {
  if (typeof width === 'object') {
    return Object.keys(width).reduce(function (props, breakpoint) {
      var _extends3;

      var breakpointSuffix = breakpoint === 'def' ? '' : "-" + breakpoint;

      if (width === 'auto') {
        var _extends2;

        return _extends({}, props, (_extends2 = {}, _extends2["flex" + breakpointSuffix] = 1, _extends2));
      }

      return _extends({}, props, (_extends3 = {}, _extends3["w" + breakpointSuffix] = width[breakpoint], _extends3));
    }, {});
  }

  return width === 'auto' ? {
    flex: 1
  } : {
    w: width
  };
};

var Col = function Col(_ref) {
  var is = _ref.is,
      children = _ref.children,
      w = _ref.w,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children", "w"]);

  return React.createElement(Box, _extends({
    is: is
  }, getWidthProps(w), rest), children);
};

Col.displayName = "Col";
Col.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  w: PropTypes.oneOfType([PropTypes.string, PropTypes.object])
};
Col.defaultProps = {
  is: 'li',
  children: undefined,
  w: 'full'
};

var Row = function Row(_ref) {
  var is = _ref.is,
      children = _ref.children,
      nowrap = _ref.nowrap,
      gutter = _ref.gutter,
      theme = _ref.theme,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "children", "nowrap", "gutter", "theme"]);

  var gutterSpacing = gutter && (gutter === true ? theme.spacing.md : theme.spacing[gutter]);
  return React.createElement(Flex, _extends({
    is: is,
    wrap: !nowrap,
    nm: gutter ? {
      l: gutterSpacing,
      b: !nowrap ? gutterSpacing : undefined
    } : undefined,
    listReset: true
  }, rest), gutter ? React.Children.map(children, function (child) {
    return React.cloneElement(child, {
      p: {
        l: gutterSpacing
      },
      m: {
        b: gutterSpacing
      }
    });
  }) : children);
};

Row.displayName = "Row";
Row.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  nowrap: PropTypes.bool,
  gutter: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])
};
Row.defaultProps = {
  is: 'ul',
  children: undefined,
  nowrap: false,
  gutter: false
};
var Row$1 = withTheme(Row);

var Header =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(Header, _PureComponent);

  function Header(props) {
    var _this;

    var id = props.id,
        screen = props.screen;
    _this = _PureComponent.call(this, props) || this;
    _this.state = {
      open: false,
      collapsable: !!screen
    };
    _this.mql = null;
    _this.id = id || getUniqueID('header');
    _this.handleMatch = _this.handleMatch.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleToggle = _this.handleToggle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  var _proto = Header.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this$props = this.props,
        theme = _this$props.theme,
        screen = _this$props.screen;

    if (screen && window.matchMedia) {
      this.mql = window.matchMedia("(min-width: " + theme.breakpoints[screen] + ")");
      this.mql.addListener(this.handleMatch);

      if (this.mql.matches) {
        this.handleMatch(this.mql);
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.mql) this.mql.removeListener(this.handleMatch);
  };

  _proto.handleToggle = function handleToggle(forceState) {
    var open = this.state.open;
    this.setState({
      open: forceState || !open
    });
  };

  _proto.handleMatch = function handleMatch(mql) {
    this.setState({
      collapsable: !mql.matches
    });
  };

  _proto.render = function render() {
    var _this$state = this.state,
        open = _this$state.open,
        collapsable = _this$state.collapsable;

    var _this$props2 = this.props,
        theme = _this$props2.theme,
        is = _this$props2.is,
        children = _this$props2.children,
        bg = _this$props2.bg,
        text = _this$props2.text,
        screen = _this$props2.screen,
        rest = _objectWithoutPropertiesLoose(_this$props2, ["theme", "is", "children", "bg", "text", "screen"]);

    var headerProps = {
      id: this.id,
      style: {
        bg: bg || theme.brandColors.primary,
        text: text || theme.textColors.on.primary
      },
      open: open,
      collapsable: collapsable,
      onToggle: this.handleToggle,
      screen: screen
    };
    return React.createElement(Box, _extends({
      is: is,
      id: headerProps.id,
      bg: headerProps.style.bg,
      text: headerProps.style.text,
      p: {
        y: theme.spacing.md
      },
      role: "banner"
    }, filterProps(rest, ['id'])), React.createElement(Container$1, {
      is: Flex,
      wrap: true,
      items: "center",
      justify: "between",
      padding: true
    }, React.Children.map(children, function (child) {
      return React.cloneElement(child, {
        header: headerProps
      });
    })));
  };

  return Header;
}(PureComponent);

Header.displayName = "Header";
Header.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  bg: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  id: PropTypes.string,
  screen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string])
};
Header.defaultProps = {
  is: 'header',
  children: undefined,
  bg: undefined,
  text: undefined,
  id: undefined,
  screen: 'lg'
};
var Header$1 = withTheme(Header);

var NavBrand = function NavBrand(_ref) {
  var _ref2;

  var theme = _ref.theme,
      _ref$header = _ref.header,
      style = _ref$header.style,
      screen = _ref$header.screen,
      is = _ref.is,
      children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "header", "is", "children"]);

  var responsive = screen ? (_ref2 = {}, _ref2["m-" + screen] = {
    r: theme.spacing.lg
  }, _ref2) : {};
  var aria = !(typeof is === 'string' && is.startsWith('h')) ? {
    role: 'heading',
    'aria-level': 1
  } : {};
  return React.createElement(Box, _extends({
    is: is,
    inlineBlock: true,
    noUnderline: true,
    flex: [true, 'no-shrink'],
    items: "center",
    h: 12,
    text: style.text || theme.textColors.on.primary
  }, responsive, aria, rest), children);
};

NavBrand.displayName = "NavBrand";
NavBrand.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  header: PropTypes.shape({
    style: PropTypes.object,
    screen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string])
  })
};
NavBrand.defaultProps = {
  is: 'div',
  children: undefined,
  header: {
    style: {},
    screen: 'lg'
  }
};
var NavBrand$1 = withTheme(NavBrand);

var NavItem = function NavItem(_ref) {
  var _ref2;

  var theme = _ref.theme,
      is = _ref.is,
      children = _ref.children,
      _ref$header = _ref.header,
      style = _ref$header.style,
      screen = _ref$header.screen,
      active = _ref.active,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "is", "children", "header", "active"]);

  var textColor = style.text || theme.textColors.on.primary;
  var bgColor = style.bg || theme.brandColors.primary;
  var responsive = screen ? (_ref2 = {}, _ref2["m-" + screen] = {
    t: 0,
    r: theme.spacing.sm
  }, _ref2) : {};
  return React.createElement(Touchable, _extends({
    is: is,
    focusable: true,
    text: !active ? style.text : style.bg,
    bg: active ? textColor : undefined,
    "bg-hocus": textColor,
    "text-hocus": bgColor,
    p: {
      x: theme.spacing.md,
      y: theme.spacing.sm
    },
    m: {
      t: theme.spacing.sm
    },
    rounded: theme.radius,
    noUnderline: true,
    block: true,
    "aria-current": active ? 'page' : undefined
  }, responsive, rest), children);
};

NavItem.displayName = "NavItem";
NavItem.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  header: PropTypes.shape({
    style: PropTypes.object,
    screen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string])
  }),
  active: PropTypes.bool
};
NavItem.defaultProps = {
  is: 'a',
  children: undefined,
  header: {
    style: {},
    screen: 'lg'
  },
  active: false
};
var NavItem$1 = withTheme(NavItem);

var NavItemWrapper = function NavItemWrapper(props) {
  return React.createElement("li", _extends({
    role: "none"
  }, props));
};

NavItemWrapper.displayName = "NavItemWrapper";

var NavMenu = function NavMenu(_ref) {
  var _ref2, _ref3;

  var theme = _ref.theme,
      transition = _ref.transition,
      is = _ref.is,
      children = _ref.children,
      header = _ref.header,
      list = _ref.list,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "transition", "is", "children", "header", "list"]);

  var transitionStyles = {
    entering: {
      maxHeight: '0',
      position: 'absolute'
    },
    entered: {
      maxHeight: '100vh'
    }
  };
  var headingId = header.id + "-menu";
  var responsive = {
    nav: header.screen ? (_ref2 = {}, _ref2["w-" + header.screen] = 'auto', _ref2["flex-" + header.screen] = true, _ref2) : {},
    menu: header.screen ? (_ref3 = {}, _ref3["flex-" + header.screen] = true, _ref3["m-" + header.screen] = {
      b: 0
    }, _ref3) : {}
  };
  return React.createElement(Box, _extends({
    is: is,
    overflow: "hidden",
    w: "full",
    flex: "grow",
    items: "center",
    h: !header.collapsable ? 12 : undefined,
    style: header.collapsable ? _extends({
      transition: 'max-height 500ms',
      maxHeight: '0'
    }, transitionStyles[transition]) : undefined,
    id: header.id + "-nav",
    "aria-labelledby": headingId,
    "aria-expanded": header.collapsable ? header.open : undefined,
    role: "navigation"
  }, responsive.nav, rest), React.createElement(Title$1, {
    level: 2,
    id: headingId,
    visuallyHidden: true
  }, "Site menu"), React.createElement(List$1, _extends({
    reset: true,
    flex: "grow",
    role: "menu",
    listItemIs: NavItemWrapper
  }, responsive.menu, list), React.Children.map(children, function (child) {
    return child.type === NavItem$1 && React.cloneElement(child, {
      header: header,
      role: 'menuitem'
    });
  })), React.Children.map(children, function (child) {
    return child.type !== NavItem$1 && child;
  }));
};

NavMenu.displayName = "NavMenu";
NavMenu.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  transition: PropTypes.string,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  children: PropTypes.node,
  header: PropTypes.shape({
    open: PropTypes.bool,
    collapsable: PropTypes.bool,
    screen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string])
  }),
  list: PropTypes.shape({})
};
NavMenu.defaultProps = {
  is: 'nav',
  children: undefined,
  header: {
    open: false,
    collapsable: false,
    screen: 'lg'
  },
  transition: 'entering',
  list: {}
};
var NavMenu$1 = withTheme(withTheme$1(NavMenu, {
  inState: 'header.open'
}));

var Bar = function Bar() {
  return React.createElement(Box, {
    inlineBlock: true,
    border: "b",
    style: {
      borderColor: 'currentColor'
    }
  });
};

Bar.displayName = "Bar";

var NavToggle = function NavToggle(_ref) {
  var _ref2;

  var theme = _ref.theme,
      children = _ref.children,
      onClick = _ref.onClick,
      _ref$header = _ref.header,
      onToggle = _ref$header.onToggle,
      style = _ref$header.style,
      id = _ref$header.id,
      screen = _ref$header.screen,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "children", "onClick", "header"]);

  var handleClick = function handleClick(e) {
    onToggle();
    if (onClick) onClick(e);
  };

  var responsive = screen ? (_ref2 = {}, _ref2["hidden-" + screen] = true, _ref2) : {};
  return React.createElement(Button$1, _extends({
    w: 12,
    h: 12,
    p: 0,
    block: true,
    onClick: handleClick,
    "aria-label": "Open menu",
    "aria-haspopup": "true",
    "aria-controls": id + "-nav",
    text: style.text || theme.textColors.on.primary,
    "bg-hocus": style.text || theme.textColors.on.primary,
    "text-hocus": style.bg || theme.brandColors.primary
  }, responsive, rest), children || React.createElement(Box, {
    flex: [true, 'col'],
    items: "stretch",
    justify: "around",
    h: "full",
    p: 3
  }, React.createElement(Bar, null), React.createElement(Bar, null), React.createElement(Bar, null)));
};

NavToggle.displayName = "NavToggle";
NavToggle.propTypes = {
  theme: PropTypes.shape({}).isRequired,
  children: PropTypes.node,
  header: PropTypes.shape({
    onToggle: PropTypes.func.isRequired,
    screen: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
    style: PropTypes.object
  }),
  onClick: PropTypes.func
};
NavToggle.defaultProps = {
  children: undefined,
  onClick: undefined,
  header: {
    style: {},
    screen: 'lg'
  }
};
var NavToggle$1 = withTheme(NavToggle);

var Main = function Main(_ref) {
  var children = _ref.children,
      is = _ref.is,
      id = _ref.id,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "is", "id"]);

  return React.createElement(Box, _extends({
    is: is,
    id: id,
    role: "main"
  }, rest), children);
};

Main.displayName = "Main";
Main.propTypes = {
  children: PropTypes.node,
  id: PropTypes.string,
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object])
};
Main.defaultProps = {
  children: undefined,
  id: 'main',
  is: 'main'
};

var SkipLink = function SkipLink(_ref) {
  var children = _ref.children,
      href = _ref.href,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "href"]);

  return React.createElement(Box, {
    visuallyHiddenFocusable: true
  }, React.createElement(FillButton, _extends({
    is: "a",
    bg: "white",
    text: "black",
    absolute: true,
    rounded: "none",
    href: href
  }, rest), children || 'Skip to main content'));
};

SkipLink.displayName = "SkipLink";
SkipLink.propTypes = {
  children: PropTypes.node,
  href: PropTypes.string
};
SkipLink.defaultProps = {
  children: undefined,
  href: '#main'
};

var SiteWrap = function SiteWrap(_ref) {
  var is = _ref.is,
      theme = _ref.theme,
      children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["is", "theme", "children"]);

  var footer;
  React.Children.forEach(children, function (child) {
    var type = child.type;

    if (type && (type === Footer$1 || type.displayName === Footer.displayName)) {
      footer = child;
    }
  });
  return React.createElement(Flex, _extends({
    is: is,
    col: true,
    minH: "screen",
    leading: "normal",
    font: theme.text.family.body,
    text: [theme.text.size.body[1], theme.textColors.body]
  }, rest), React.createElement(Box, {
    flex: ['auto', 'no-shrink']
  }, React.Children.map(children, function (child) {
    if (child === footer) return false;
    return child;
  })), React.createElement(Box, {
    flex: ['auto', 'no-shrink', 'no-grow'],
    m: {
      t: theme.spacing.lg
    }
  }, footer));
};

SiteWrap.displayName = "SiteWrap";
SiteWrap.propTypes = {
  is: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]),
  theme: PropTypes.shape({}).isRequired,
  children: PropTypes.node
};
SiteWrap.defaultProps = {
  is: 'div',
  children: undefined
};
var SiteWrap$1 = withTheme(SiteWrap);

export { Button$1 as Button, FillButton, OutlineButton, TextButton, LinkButton, Card$1 as Card, CardBody$1 as CardBody, CardFooter, Container$1 as Container, ContentTitle, ContentBlock$1 as ContentBlock, Article, Aside, Section, Footer$1 as Footer, ErrorText, Field$1 as Field, HelpText, Label$1 as Label, Select$1 as Select, TextInput$1 as TextInput, Radio, Checkbox, OptionList$1 as OptionList, Col, Row$1 as Row, Header$1 as Header, NavBrand$1 as NavBrand, NavItem$1 as NavItem, NavMenu$1 as NavMenu, NavToggle$1 as NavToggle, List$1 as List, Main, SkipLink, Base$1 as Base, Box, Flex, Image, Text, Touchable, SiteWrap$1 as SiteWrap, Subtitle, Paragraph$1 as Paragraph, Title$1 as Title, BrandText$1 as BrandText, DangerText, InfoText, WarningText, getColorShade, getTailwindClassNames, tailwindProps, propTypes, propVariants, tailwindPropToClassName, withTailwind, defaultTheme, TailwindTheme, TailwindThemeProvider, withTheme, useThemeValue, getAsArray, filterProps, getUniqueID, withTheme$1 as withTransition };
